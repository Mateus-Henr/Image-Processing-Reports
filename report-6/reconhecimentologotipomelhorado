import cv2
import os
import inspect
import numpy as np





def comparar_contornos(contorno_teste, contorno_referencia, tolerancia=0.7):
    
    # Calcula a similaridade entre os contornos
    similaridade = cv2.matchShapes(contorno_teste, contorno_referencia, cv2.CONTOURS_MATCH_I2, 0)
    print(similaridade)
    
    # Define a margem de erro baseada na tolerância
    margem_erro = tolerancia * cv2.arcLength(contorno_referencia, True)
    
    # Verifica se a similaridade está dentro da margem de erro
    if similaridade < 0.15:
        return True
    else:
        return False

# Função auxiliar para imprimir a linha do código
def imprimir_linha_codigo():
    frame = inspect.currentframe().f_back
    linha = frame.f_lineno
    arquivo = frame.f_code.co_filename
    print(f"Linha {linha} em {arquivo}")

imprimir_linha_codigo()

# Função para calcular o contorno de uma imagem
def calcular_contorno(imagem):
    imagem_gray = cv2.cvtColor(imagem, cv2.COLOR_BGR2GRAY)
    imagem_bin=cv2.adaptiveThreshold(imagem_gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, 11, 2)
    imagem_bin= cv2.dilate(imagem_bin,(3,3),1)
    #cv2.imshow("depois otsu",imagem_bin)
    #cv2.waitKey(1000)
    contornos, _ = cv2.findContours(imagem_bin, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    
    # Ordenar os contornos pela área, do maior para o menor
    contornos = sorted(contornos, key=cv2.contourArea, reverse=True)
    
    contorno_principal = contornos[0]
    print(cv2.contourArea(contorno_principal))
    print(imagem.shape[0] * imagem.shape[1])
    
        # Tolerância para comparar as áreas
    tolerancia = 0.05  # 5%
    
    # Se o contorno principal for a imagem inteira, considerar o segundo maior contorno
    if abs(cv2.contourArea(contorno_principal) - imagem.shape[0] * imagem.shape[1]) / (imagem.shape[0] * imagem.shape[1]) < tolerancia:
        if len(contornos) > 1:
            contorno_principal = contornos[1]
        else:
            return None
        
    # Se o contorno principal for maior que 1000 pixels, desenhar na imagem
    if cv2.contourArea(contorno_principal) > 100:
        #imagem2=imagem
        #cv2.drawContours(imagem2, [contorno_principal], -1, (0, 255, 0), 2)
        #cv2.imshow("contornos",imagem2)
        #cv2.waitKey(1000)
        return contorno_principal
    else:
        return None

# Diretório da pasta "logotipo/teste"
diretorio_modelo = "logotipo\modelos"

# Ler as imagens da pasta "logotipo/teste" e calcular o contorno
contornos_teste = []
for imagem_teste in sorted(os.listdir(diretorio_modelo)):
    #print(imagem_teste)
    if imagem_teste.lower() != "desktop.ini":
        
    
        caminho_imagem_teste = os.path.join(diretorio_modelo, imagem_teste)
        imprimir_linha_codigo()
        print(caminho_imagem_teste)
        imagem = cv2.imread(caminho_imagem_teste)
        cv2.imshow("Procurando....",imagem)
        cv2.waitKey(100)
        contorno = calcular_contorno(imagem)
        if contorno is not None:
            contornos_teste.append((caminho_imagem_teste, contorno))


# Diretório da pasta "logotipo"
diretorio_teste = "logotipo/teste"
contador=0
# Percorrer as pastas dentro de "logotipo/teste"
for pasta_marca in os.listdir(diretorio_teste):
    print(f" Pasta {pasta_marca}")
    caminho_pasta_marca = os.path.join(diretorio_teste, pasta_marca)
    if os.path.isdir(caminho_pasta_marca):
        # Percorrer as imagens da pasta da marca
        for imagem_marca in os.listdir(caminho_pasta_marca):
            print(f" Arquivo  {imagem_marca}")
            if imagem_marca.lower() != "desktop.ini":
                  
                caminho_imagem_marca = os.path.join(caminho_pasta_marca, imagem_marca)
                imagem = cv2.imread(caminho_imagem_marca)
                cv2.imshow("Encontrado",imagem)
                cv2.waitKey(1)
                imprimir_linha_codigo()
                contorno_marca = calcular_contorno(imagem)
                if contorno_marca is not None:
                    # Comparar o contorno da imagem da marca com os contornos das imagens de teste
                    for caminho_imagem_teste, contorno_teste in contornos_teste:
                        if comparar_contornos(contorno_teste, contorno_marca, tolerancia=0.3):

                            print(f"A imagem {pasta_marca}_{imagem_marca} é semelhante a {caminho_imagem_teste}")
                            imagem_original=cv2.imread(caminho_imagem_teste)
                            altura_original, largura_original, _ = imagem_original.shape
                            altura_semelhante, largura_semelhante, _ = imagem.shape

                            # Verificar qual imagem é maior
                            if (altura_original * largura_original) > (altura_semelhante * largura_semelhante):
                                # Redimensionar a imagem semelhante para o tamanho da imagem original
                                imagem = cv2.resize(imagem, (largura_original, altura_original))
                            else:
                                # Redimensionar a imagem original para o tamanho da imagem semelhante
                                imagem_original = cv2.resize(imagem_original, (largura_semelhante, altura_semelhante))

                            # Concatenar as imagens horizontalmente
                       
                            
                            imagens_concatenadas = np.hstack((imagem_original, imagem))
                            #Exibir as imagens concatenadas
                            cv2.imshow("Imagens Semelhantes", imagens_concatenadas)
                            cv2.waitKey(1000)
                            cv2.destroyAllWindows()
                            contador=contador+1
                            
cv2.destroyAllWindows()
print("foram encontradas %d imagens iguais" % contador)
                            


